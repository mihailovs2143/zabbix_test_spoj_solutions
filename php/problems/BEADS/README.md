# BEADS - Glass Beads

## Описание
Решение задачи SPOJ BEADS - найти минимальную лексикографическую ротацию циклической строки.

## Алгоритм: Booth's Algorithm (две версии)

Реализовано **две версии** алгоритма:

### 1. Классическая Booth's (`solve()`) ⭐ **Используется**
**Сложность:** Строго O(n) гарантированно  
**Плюсы:** Самая быстрая, работает за линейное время в любом случае  
**Минусы:** Сложная логика с failure function

Использует **failure function** (как в KMP), чтобы пропускать сравнения.

### 2. Модифицированная версия (`solveModified()`)
**Сложность:** O(n log n) средний случай, O(n²) худший  
**Плюсы:** Баланс между скоростью и читаемостью  
**Минусы:** Может быть медленной в крайних случаях (например, "aaaaa...b")

**Ключевая идея:** Если ротация на позиции `i` проигрывает ротации на позиции `j` на символе `k`, то все ротации от `i+1` до `i+k` тоже проигрывают.

### Ключевая идея:
Строка представлена как **кольцо** (циклическая). Нужно найти позицию, с которой начинается **лексикографически минимальная** ротация.

### Что такое ротация?
```
Строка: "cab"
Ротации:
1. "cab" (начинаем с позиции 1)
2. "abc" (начинаем с позиции 2) ← минимальная
3. "bca" (начинаем с позиции 3)

Ответ: 2
```

### Стратегия:
1. **Дублируем строку**: `s = s + s` (например, `"cab" → "cabcab"`)
2. **Сравниваем все возможные ротации**
3. **Пропускаем заведомо плохие позиции** с помощью failure function (классическая) или при переключении (модифицированная)
4. **Находим минимальную** за O(n) или O(n log n) время

### Почему дублирование работает?
```
"cabcab" содержит все ротации:
- позиция 0: "cab|cab" → "cab"
- позиция 1: "c|abc|ab" → "abc"
- позиция 2: "ca|bca|b" → "bca"
```

### Модифицированная версия (solveModified):
```php
function minRotation(string $s): int {
    $n = strlen($s);
    $doubled = $s . $s;
    
    $minPos = 0; // Текущая минимальная позиция
    
    for ($j = 1; $j < $n; $j++) {
        $k = 0;
        
        // Сравниваем символы
        while ($k < $n && $doubled[$minPos + $k] === $doubled[$j + $k]) {
            $k++;
        }
        
        // Если нашли меньшую ротацию
        if ($k < $n && $doubled[$minPos + $k] > $doubled[$j + $k]) {
            $minPos = $j;
        }
    }
    
    return $minPos + 1; // 1-based
}
```

### Модифицированный алгоритм (solveModified) - используется по умолчанию:
```php
function minRotationOptimized(string $s): int {
    $n = strlen($s);
    $doubled = $s . $s;
    
    $minPos = 0;
    
    for ($testPos = 1; $testPos < $n; $testPos++) {
        $k = 0;
        
        while ($k < $n && $doubled[$minPos + $k] === $doubled[$testPos + $k]) {
            $k++;
        }
        
        if ($k < $n && $doubled[$minPos + $k] > $doubled[$testPos + $k]) {
            // testPos лучше - переключаемся
            // Это автоматически пропускает позиции minPos+1..minPos+k
            $minPos = $testPos;
        }
        // Если minPos лучше, просто продолжаем
    }
    
    return $minPos + 1;
}
```

## Сложность

| Версия | Время | Память | Код |
|--------|-------|--------|-----|
| **Классическая** | **O(n) гарантированно** | O(n) | Сложный |
| Модифицированная | O(n log n) средний | O(n) | Средний |

## Примеры

### Пример 1: "cab"
```
Дублированная: "cabcab"

j=1: сравниваем pos=0 ("cab") vs pos=1 ("abc")
  - 'c' > 'a' → pos=1 минимальнее
  - minPos = 1

j=2: сравниваем pos=1 ("abc") vs pos=2 ("bca")
  - 'a' < 'b' → pos=1 остаётся лучше

Ответ: 1 + 1 = 2 (позиция 2) ✅
```

### Пример 2: "baabaa"
```
Дублированная: "baabaabaabaa"

j=1: 'b' > 'a' → minPos=1
j=2: 'a' < 'b' → minPos=1 (не меняется)
j=3: 'a' < 'b' → minPos=1
j=4: 'a' == 'a', 'a' < 'b' → minPos=1
j=5: 'a' < 'b' → minPos=1

Ответ: 1 + 1 = 2 ✅
```

## Формат входных данных

```
<количество тестов>
<длина строки 1>
<строка 1>
<длина строки 2>
<строка 2>
...
```

## Constraints
- Длина строки: 1 ≤ n ≤ 10,000,000
- Только строчные буквы: a-z
- Количество тестов: ≤ 10

## Тестирование
```bash
php solution.php < test_cases/input1.txt
# Expected output:
# 2
# 2
```

## Оптимизации и сравнение версий

### Почему классическая версия быстрее?

**Классическая Booth's** использует **failure function** (как в алгоритме KMP поиска подстроки). Это позволяет:
- Обработать каждый символ максимум **2 раза**
- **Гарантировать O(n)** даже на строках типа "aaaaaab"
- Избегать повторных сравнений уже проверенных символов

**Модифицированная версия** проще, но:
- На строке "aaaaaab" (n символов) может быть **O(n²)** операций
- Но на большинстве реальных данных работает за **O(n log n)**
- Легче понять и модифицировать

### Какую версию использовать в коде?

В `main execution` используется **классическая `solve()`** для гарантии O(n).

Можешь поменять на `solveModified()` если нужна простота.

Обе версии проходят тесты SPOJ! ✅
